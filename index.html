<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dreamy Wallpapers Editor </title>
  <style>
    /* --- Reset & base styles --- */
    * {
      box-sizing: border-box;
    }
    body, html {
      margin: 0; padding: 0;
      height: 100%;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f0f0f5;
      color: #222;
      overflow: hidden;
      user-select: none;
    }
    button, input, select, textarea {
      font-family: inherit;
      font-size: 14px;
      outline: none;
    }
    /* --- Layout --- */
    #app {
      display: flex;
      height: 100vh;
      width: 100vw;
      background: #fafafa;
      overflow: hidden;
    }
    /* --- Sidebar for tools --- */
    #sidebar {
      width: 300px;
      background: #fff;
      border-right: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.05);
      overflow-y: auto;
      user-select: text;
    }
    #sidebar h2 {
      margin-top: 0;
      margin-bottom: 12px;
      color: #ff1493;
      font-weight: 700;
      font-size: 20px;
      text-align: center;
    }

    /* --- Canvas container --- */
    #canvas-container {
      flex-grow: 1;
      background: linear-gradient(45deg, #e0e0eb 25%, transparent 25%), 
                  linear-gradient(-45deg, #e0e0eb 25%, transparent 25%), 
                  linear-gradient(45deg, transparent 75%, #e0e0eb 75%), 
                  linear-gradient(-45deg, transparent 75%, #e0e0eb 75%);
      background-size: 40px 40px;
      background-position: 0 0, 0 20px, 20px -20px, -20px 0px;
      position: relative;
      overflow: hidden;
    }

    canvas {
      background: #fff;
      display: block;
      margin: auto;
      max-width: 100%;
      max-height: 100vh;
      cursor: crosshair;
      user-select: none;
    }

    /* --- Secret input --- */
    #secretInput {
      opacity: 0.4;
      font-size: 14px;
      border: none;
      border-bottom: 1.5px solid #888;
      background: transparent;
      color: #666;
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 140px;
      padding: 6px 10px;
      outline: none;
      transition: opacity 0.3s, color 0.3s, border-color 0.3s;
      border-radius: 6px 6px 0 0;
      z-index: 10000;
      user-select: text;
      font-weight: 600;
      letter-spacing: 0.05em;
    }
    #secretInput:focus {
      opacity: 1;
      color: #222;
      border-color: #ff69b4;
      background: #fff;
      box-shadow: 0 0 12px #ff69b4aa;
    }

    /* --- Mood popup --- */
    .mood-popup {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      color: #000;
      padding: 28px 30px;
      border-radius: 18px;
      max-width: 420px;
      box-shadow: 0 0 28px rgba(0,0,0,0.25);
      z-index: 10010;
      font-weight: 600;
      user-select: none;
      font-size: 18px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    .mood-popup h3 {
      margin-top: 0;
      color: #ff1493;
      font-weight: 900;
      margin-bottom: 14px;
      font-size: 24px;
      text-align: center;
    }
    .mood-popup ul {
      list-style: none;
      padding-left: 0;
      margin-bottom: 0;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .mood-popup li {
      cursor: pointer;
      padding: 10px 16px;
      border-radius: 12px;
      border: 2px solid transparent;
      transition: background-color 0.25s, border-color 0.25s, color 0.25s;
      color: #333;
      user-select: none;
      text-align: center;
      background-color: #fafafa;
    }
    .mood-popup li:hover {
      background-color: #ffe0f7;
      border-color: #ff1493;
      color: #ff1493;
    }

    /* --- Next button --- */
    #nextBtn {
      position: fixed;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #ff69b4;
      color: white;
      font-size: 17px;
      font-weight: 700;
      padding: 14px 38px;
      border: none;
      border-radius: 999px;
      box-shadow: 0 6px 20px rgba(255,105,180,0.6);
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
      z-index: 10001;
      user-select: none;
    }
    #nextBtn:hover {
      background-color: #ff85c1;
      transform: translateX(-50%) scale(1.05);
    }

    /* --- Stickers grid --- */
    #stickersGrid {
      display: grid;
      grid-template-columns: repeat(5, 50px);
      grid-gap: 10px;
      justify-content: center;
      margin-top: 6px;
      user-select: none;
    }
    #stickersGrid img {
      width: 48px;
      height: 48px;
      object-fit: contain;
      cursor: grab;
      border-radius: 8px;
      box-shadow: 0 0 6px #aaa;
      transition: box-shadow 0.25s ease;
    }
    #stickersGrid img:hover {
      box-shadow: 0 0 14px #ff1493;
      cursor: pointer;
    }

    /* --- Layers panel --- */
    #layersPanel {
      margin-top: 20px;
      border-top: 1px solid #ddd;
      padding-top: 12px;
      font-size: 14px;
      max-height: 140px;
      overflow-y: auto;
      user-select: text;
    }
    #layersPanel h3 {
      margin-top: 0;
      font-weight: 600;
      color: #ff1493;
      font-size: 18px;
      margin-bottom: 8px;
      user-select: none;
      text-align: center;
    }
    #layersPanel ul {
      list-style: none;
      margin: 0;
      padding-left: 0;
    }
    #layersPanel li {
      padding: 6px 12px;
      background: #fafafa;
      margin-bottom: 6px;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    #layersPanel li:hover {
      background-color: #ffdef0;
      color: #ff1493;
    }
    #layersPanel li.active {
      background-color: #ff1493;
      color: white;
      font-weight: 700;
      box-shadow: 0 0 10px #ff1493aa;
    }

    /* --- Controls --- */
    .control-group {
      margin-bottom: 18px;
    }
    .control-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
      color: #333;
    }
    .control-group input[type="range"] {
      width: 100%;
    }
    .control-group input[type="text"], 
    .control-group input[type="number"], 
    .control-group select {
      width: 100%;
      padding: 6px 10px;
      border: 1.5px solid #ddd;
      border-radius: 6px;
      transition: border-color 0.25s ease;
      font-weight: 600;
    }
    .control-group input[type="text"]:focus, 
    .control-group input[type="number"]:focus, 
    .control-group select:focus {
      border-color: #ff1493;
      outline: none;
    }
    .small-button {
      background: #ff1493;
      border: none;
      color: white;
      padding: 6px 14px;
      border-radius: 999px;
      font-weight: 700;
      cursor: pointer;
      transition: background-color 0.3s ease;
      user-select: none;
      margin-left: 8px;
    }
    .small-button:hover {
      background: #ff69b4;
    }

    /* --- Text editing panel --- */
    #textControls {
      margin-top: 20px;
      padding-top: 12px;
      border-top: 1px solid #ddd;
    }

    /* --- Canvas overlay for selection highlights --- */
    #canvasOverlay {
      position: absolute;
      top: 0; left: 0;
      pointer-events: none;
    }

    /* --- Tooltip --- */
    .tooltip {
      position: fixed;
      background: #ff1493dd;
      color: white;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      user-select: none;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 11000;
    }
  </style>
</head>
<body>

  <div id="app">
    <aside id="sidebar">
      <h2>Tools & Stickers</h2>
      
      <div class="control-group">
        <label for="bgColor">Background Color</label>
        <input type="color" id="bgColor" value="#ffffff" title="Set background color" />
      </div>
      <div class="control-group">
        <label for="brightnessRange">Brightness</label>
        <input type="range" id="brightnessRange" min="50" max="150" value="100" />
      </div>
      <div class="control-group">
        <label for="saturationRange">Saturation</label>
        <input type="range" id="saturationRange" min="0" max="200" value="100" />
      </div>

      <hr style="margin: 20px 0; border-color: #eee" />

      <h3>Text Tool</h3>
      <div id="textControls">
        <div class="control-group">
          <label for="textInput">Text</label>
          <input type="text" id="textInput" placeholder="Type here..." />
        </div>
        <div class="control-group">
          <label for="fontSizeInput">Font size (px)</label>
          <input type="number" id="fontSizeInput" min="8" max="200" value="32" />
        </div>
        <div class="control-group">
          <label for="textColorInput">Text color</label>
          <input type="color" id="textColorInput" value="#ff1493" />
        </div>
        <div class="control-group">
          <label for="textRotateInput">Rotation (degrees)</label>
          <input type="number" id="textRotateInput" min="0" max="360" value="0" />
        </div>
        <button id="addTextBtn" class="small-button">Add Text</button>
      </div>

      <hr style="margin: 20px 0; border-color: #eee" />

      <h3>Brush Tool</h3>
      <div class="control-group">
        <label for="brushColorInput">Brush Color</label>
        <input type="color" id="brushColorInput" value="#ff1493" />
      </div>
      <div class="control-group">
        <label for="brushSizeInput">Brush Size</label>
        <input type="range" id="brushSizeInput" min="1" max="50" value="5" />
      </div>
      <button id="toggleBrushBtn" class="small-button">Start Drawing</button>

      <hr style="margin: 20px 0; border-color: #eee" />

      <h3>Stickers</h3>
      <div id="stickersGrid" title="Click to add sticker"></div>

      <hr style="margin: 20px 0; border-color: #eee" />

      <h3>Layers</h3>
      <div id="layersPanel">
        <ul></ul>
      </div>

      <button id="clearCanvasBtn" class="small-button" style="width: 100%; margin-top: 12px;">Clear Canvas</button>
    </aside>

    <main id="canvas-container">
      <canvas id="canvas" width="800" height="600"></canvas>
      <canvas id="canvasOverlay" width="800" height="600"></canvas>
    </main>
  </div>

  <input type="text" id="secretInput" placeholder="..." autocomplete="off" spellcheck="false" />

  <button id="nextBtn">Next ‚Üí</button>

  <div class="tooltip" id="tooltip" style="opacity:0; pointer-events:none;">Tooltip</div>

<script>
(() => {
  // --- State ---
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('canvasOverlay');
  const octx = overlay.getContext('2d');

  const bgColorInput = document.getElementById('bgColor');
  const brightnessRange = document.getElementById('brightnessRange');
  const saturationRange = document.getElementById('saturationRange');

  const textInput = document.getElementById('textInput');
  const fontSizeInput = document.getElementById('fontSizeInput');
  const textColorInput = document.getElementById('textColorInput');
  const textRotateInput = document.getElementById('textRotateInput');
  const addTextBtn = document.getElementById('addTextBtn');

  const brushColorInput = document.getElementById('brushColorInput');
  const brushSizeInput = document.getElementById('brushSizeInput');
  const toggleBrushBtn = document.getElementById('toggleBrushBtn');

  const stickersGrid = document.getElementById('stickersGrid');
  const layersPanel = document.getElementById('layersPanel').querySelector('ul');
  const clearCanvasBtn = document.getElementById('clearCanvasBtn');

  const secretInput = document.getElementById('secretInput');
  const nextBtn = document.getElementById('nextBtn');
  const tooltip = document.getElementById('tooltip');

  // Canvas size constants
  const CANVAS_WIDTH = canvas.width;
  const CANVAS_HEIGHT = canvas.height;
  overlay.width = CANVAS_WIDTH;
  overlay.height = CANVAS_HEIGHT;

  // Model for elements on canvas: stickers and text objects
  // Each item: { id, type: 'sticker'|'text'|'drawing', img?, text?, x, y, scale, rotation, color?, fontSize?, brushPath?, brushColor?, brushSize? }
  let elements = [];
  let activeElementId = null;

  // Brush drawing state
  let isDrawing = false;
  let brushPath = [];

  // Stickers sources (filenames as placeholders)
  const stickerCountDefault = 15;
  const stickerCountBubbleGum = 25;
  // Array to store sticker URLs for 1.png ... 15.png etc
  // User said: 1.png ... 15.png for default, 25 for Bubble_Gum
  // Since we don't have real images, placeholders will be colored squares with number

  // For demo, generate stickers as colored SVG data URLs dynamically
  function generateStickerSVG(number) {
    const colors = [
      '#ffadad', '#ffd6a5', '#fdffb6', '#caffbf', '#9bf6ff', '#a0c4ff',
      '#bdb2ff', '#ffc6ff', '#fffffc', '#d0f4de', '#f9dcc4', '#fca311',
      '#14213d', '#f4d35e', '#ee6c4d', '#3d405b', '#81b29a', '#f2cc8f',
      '#e07a5f', '#f4f1de', '#a5a58d', '#6b4226', '#5f0f40', '#9a031e', '#fb8b24',
    ];
    const c = colors[number % colors.length];
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48">
      <rect width="48" height="48" fill="${c}" rx="12" ry="12"/>
      <text x="24" y="28" font-size="18" font-family="Arial" fill="#222" text-anchor="middle" font-weight="bold">${number}</text>
    </svg>`;
    return 'data:image/svg+xml;base64,' + btoa(svg);
  }

  // We'll store stickers URLs in an array for convenience
  let stickersDefault = [];
  for (let i=1; i<=stickerCountDefault; i++) {
    stickersDefault.push(generateStickerSVG(i));
  }
  let stickersBubbleGum = [];
  for (let i=1; i<=stickerCountBubbleGum; i++) {
    stickersBubbleGum.push(generateStickerSVG(i));
  }

  // Current stickers set to display in sidebar
  let currentStickers = stickersDefault;

  // --- Initialize stickers grid ---
  function fillStickersGrid(type='default') {
    stickersGrid.innerHTML = '';
    currentStickers = (type === 'bubblegum') ? stickersBubbleGum : stickersDefault;
    currentStickers.forEach((src, i) => {
      const img = document.createElement('img');
      img.src = src;
      img.alt = `Sticker ${i+1}.png`;
      img.title = `Sticker ${i+1}.png`;
      img.draggable = false;
      img.addEventListener('click', () => {
        addSticker(i);
      });
      stickersGrid.appendChild(img);
    });
  }

  // --- Add sticker to canvas ---
  function addSticker(index) {
    const id = 'el' + Date.now() + Math.floor(Math.random()*1000);
    const stickerSrc = currentStickers[index];
    const img = new Image();
    img.src = stickerSrc;
    img.onload = () => {
      const el = {
        id,
        type: 'sticker',
        img,
        x: CANVAS_WIDTH/2 - img.width/2,
        y: CANVAS_HEIGHT/2 - img.height/2,
        scale: 1,
        rotation: 0,
        width: img.width,
        height: img.height,
      };
      elements.push(el);
      setActiveElement(id);
      redrawCanvas();
      updateLayersPanel();
    };
  }

  // --- Add text to canvas ---
  function addText() {
    const text = textInput.value.trim();
    if (!text) return alert('Enter some text first!');
    const id = 'el' + Date.now() + Math.floor(Math.random()*1000);
    const fontSize = parseInt(fontSizeInput.value) || 32;
    const color = textColorInput.value || '#ff1493';
    const rotation = parseFloat(textRotateInput.value) || 0;
    const el = {
      id,
      type: 'text',
      text,
      x: CANVAS_WIDTH/2,
      y: CANVAS_HEIGHT/2,
      scale: 1,
      rotation,
      color,
      fontSize,
    };
    elements.push(el);
    setActiveElement(id);
    redrawCanvas();
    updateLayersPanel();
    textInput.value = '';
  }

  // --- Drawing with brush ---
  function startDrawing() {
    isDrawing = true;
    brushPath = [];
    overlay.style.cursor = 'crosshair';
    toggleBrushBtn.textContent = 'Stop Drawing';
  }
  function stopDrawing() {
    if (isDrawing && brushPath.length) {
      // Save brush stroke as new element
      const id = 'el' + Date.now() + Math.floor(Math.random()*1000);
      const el = {
        id,
        type: 'drawing',
        brushPath: brushPath.slice(),
        brushColor: brushColorInput.value,
        brushSize: parseInt(brushSizeInput.value),
      };
      elements.push(el);
      updateLayersPanel();
      redrawCanvas();
    }
    isDrawing = false;
    brushPath = [];
    overlay.style.cursor = 'default';
    toggleBrushBtn.textContent = 'Start Drawing';
  }

  // --- Mouse event handlers for brush and drag ---
  let dragOffset = {x:0,y:0};
  let isDragging = false;
  let dragElement = null;
  let lastMousePos = {x:0,y:0};

  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) * (canvas.width/rect.width),
      y: (evt.clientY - rect.top) * (canvas.height/rect.height),
    };
  }

  // Check if mouse is inside element bounds (rough box)
  function isPointInElement(x,y,el) {
    if (el.type === 'sticker' || el.type === 'drawing') {
      // Use bounding box
      // For rotation, approximate with circle radius (max dimension)
      const cx = el.x + (el.width ? el.width*el.scale/2 : 0);
      const cy = el.y + (el.height ? el.height*el.scale/2 : 0);
      const maxDim = Math.max(el.width || 0, el.height || 0)*el.scale/2;
      const dist = Math.sqrt((x-cx)**2 + (y-cy)**2);
      return dist <= maxDim;
    } else if (el.type === 'text') {
      // Approximate text bounding box (centered at x,y)
      const ctxTemp = ctx;
      ctxTemp.font = `${el.fontSize}px Segoe UI, Tahoma, Geneva, Verdana, sans-serif`;
      const textWidth = ctxTemp.measureText(el.text).width * el.scale;
      const textHeight = el.fontSize * el.scale;
      // simple box around (x,y)
      const left = el.x - textWidth/2;
      const right = el.x + textWidth/2;
      const top = el.y - textHeight/2;
      const bottom = el.y + textHeight/2;
      return x>=left && x<=right && y>=top && y<=bottom;
    }
    return false;
  }

  // Select element on mouse down
  function onMouseDown(evt) {
    const pos = getMousePos(evt);
    lastMousePos = pos;
    if (isDrawing) {
      brushPath.push(pos);
      return;
    }
    // Check elements in reverse order (top first)
    for(let i=elements.length-1; i>=0; i--) {
      if (isPointInElement(pos.x, pos.y, elements[i])) {
        setActiveElement(elements[i].id);
        dragOffset.x = pos.x - elements[i].x;
        dragOffset.y = pos.y - elements[i].y;
        isDragging = true;
        dragElement = elements[i];
        redrawCanvas();
        return;
      }
    }
    // If clicked outside elements, clear selection
    setActiveElement(null);
    redrawCanvas();
  }
  function onMouseMove(evt) {
    const pos = getMousePos(evt);
    if (isDrawing) {
      brushPath.push(pos);
      redrawOverlay();
      return;
    }
    if (isDragging && dragElement) {
      dragElement.x = pos.x - dragOffset.x;
      dragElement.y = pos.y - dragOffset.y;
      redrawCanvas();
      redrawOverlay();
      return;
    }
    // Tooltip
    tooltip.style.opacity = 0;
  }
  function onMouseUp(evt) {
    if (isDrawing) {
      stopDrawing();
      redrawCanvas();
      redrawOverlay();
      return;
    }
    if (isDragging) {
      isDragging = false;
      dragElement = null;
    }
  }

  // --- Redraw canvas ---
  function redrawCanvas() {
    // Clear canvas & apply background color + filters
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Apply filters
    const brightness = brightnessRange.value / 100;
    const saturation = saturationRange.value / 100;
    ctx.filter = `brightness(${brightness}) saturate(${saturation})`;

    // Fill background
    ctx.fillStyle = bgColorInput.value;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw all elements in order
    elements.forEach(el => {
      ctx.save();
      ctx.translate(el.x, el.y);
      ctx.rotate((el.rotation||0)*Math.PI/180);
      ctx.scale(el.scale || 1, el.scale || 1);

      if (el.type === 'sticker' && el.img) {
        ctx.drawImage(el.img, -el.img.width/2, -el.img.height/2);
      } else if (el.type === 'text' && el.text) {
        ctx.fillStyle = el.color || '#000';
        ctx.font = `${el.fontSize || 32}px Segoe UI, Tahoma, Geneva, Verdana, sans-serif`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(el.text, 0, 0);
      } else if (el.type === 'drawing' && el.brushPath) {
        ctx.strokeStyle = el.brushColor || '#000';
        ctx.lineWidth = el.brushSize || 5;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.beginPath();
        el.brushPath.forEach((pt, i) => {
          if(i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.stroke();
      }
      ctx.restore();
    });

    ctx.filter = 'none';

    redrawOverlay();
  }

  // --- Redraw overlay for selection ---
  function redrawOverlay() {
    octx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    if (!activeElementId) return;
    const el = elements.find(e => e.id === activeElementId);
    if (!el) return;
    octx.save();
    octx.translate(el.x, el.y);
    octx.rotate((el.rotation||0)*Math.PI/180);
    octx.scale(el.scale || 1, el.scale || 1);
    octx.strokeStyle = '#ff1493';
    octx.lineWidth = 3;
    octx.setLineDash([8,6]);
    if (el.type === 'sticker' && el.img) {
      octx.strokeRect(-el.img.width/2, -el.img.height/2, el.img.width, el.img.height);
    } else if (el.type === 'text' && el.text) {
      const textWidth = ctx.measureText(el.text).width * (el.scale||1);
      const textHeight = el.fontSize * (el.scale||1);
      octx.strokeRect(-textWidth/2, -textHeight/2, textWidth, textHeight);
    } else if (el.type === 'drawing' && el.brushPath) {
      // For drawing, highlight bounding box of points
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      el.brushPath.forEach(p => {
        if(p.x < minX) minX = p.x;
        if(p.y < minY) minY = p.y;
        if(p.x > maxX) maxX = p.x;
        if(p.y > maxY) maxY = p.y;
      });
      octx.strokeRect(minX, minY, maxX-minX, maxY-minY);
    }
    octx.restore();
  }

  // --- Set active element ---
  function setActiveElement(id) {
    activeElementId = id;
    updateLayersPanel();
    redrawOverlay();
  }

  // --- Update layers panel ---
  function updateLayersPanel() {
    layersPanel.innerHTML = '';
    for (let i = elements.length -1; i>=0; i--) {
      const el = elements[i];
      const li = document.createElement('li');
      li.textContent = `${el.type === 'sticker' ? 'Sticker' : el.type === 'text' ? 'Text' : 'Drawing'} #${i+1}`;
      if (el.id === activeElementId) {
        li.classList.add('active');
      }
      li.addEventListener('click', () => {
        setActiveElement(el.id);
      });
      layersPanel.appendChild(li);
    }
  }

  // --- Clear canvas and reset ---
  function clearCanvas() {
    if (!confirm('Clear canvas and remove all elements?')) return;
    elements = [];
    activeElementId = null;
    redrawCanvas();
    updateLayersPanel();
  }

  // --- Update background ---
  function updateBackground() {
    redrawCanvas();
  }

  // --- Secret Input handling ---
  secretInput.addEventListener('input', () => {
    const val = secretInput.value.trim();
    const today = new Date().getDate().toString().padStart(2,'0');

    if (val === '0103') {
      // Redirect to yukki secret page
      window.location.href = 'secret/yukki.html';
    } else if (val.toLowerCase() === 'bubble_gum'.toLowerCase()) {
      // Switch to Bubble Gum stickers (25)
      fillStickersGrid('bubblegum');
      alert('Bubble Gum mode: Stickers set changed.');
      secretInput.value = '';
    } else if (val === today) {
      showMoodPopup();
      secretInput.value = '';
    }
    // No message on wrong code, do nothing
  });

  // --- Mood popup ---
  function showMoodPopup() {
    if(document.querySelector('.mood-popup')) return;
    const container = document.createElement('div');
    container.className = 'mood-popup';
    container.innerHTML = `
      <h3>‚ú® What mood are you feeling today?</h3>
      <ul>
        <li data-mood="cute">‚Ä¢ Cute and cozy</li>
        <li data-mood="fire">‚Ä¢ Fiery, explosive, intense</li>
        <li data-mood="water">‚Ä¢ Watery, soft, like little fish üêü‚ù§Ô∏è</li>
        <li data-mood="sweet">‚Ä¢ Sweet and sugary üç¨</li>
        <li data-mood="creative">‚Ä¢ Creative, inspired, artistic üé®</li>
      </ul>
    `;
    document.body.appendChild(container);
    container.querySelectorAll('li').forEach(li => {
      li.addEventListener('click', () => {
        alert(`You chose mood: "${li.textContent.trim()}"! Cool!`);
        container.remove();
      });
    });
  }

  // --- Next button handler ---
  nextBtn.addEventListener('click', () => {
    // Go to second page/site (example)
    window.location.href = 'index2.html';
  });

  // --- Brush tool toggle ---
  toggleBrushBtn.addEventListener('click', () => {
    if (isDrawing) {
      stopDrawing();
    } else {
      startDrawing();
    }
  });

  // --- Add text button ---
  addTextBtn.addEventListener('click', addText);

  // --- Clear canvas button ---
  clearCanvasBtn.addEventListener('click', clearCanvas);

  // --- Input handlers for background controls ---
  bgColorInput.addEventListener('input', updateBackground);
  brightnessRange.addEventListener('input', updateBackground);
  saturationRange.addEventListener('input', updateBackground);

  // --- Canvas mouse events ---
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('mouseleave', onMouseUp);

  overlay.addEventListener('mousedown', onMouseDown);
  overlay.addEventListener('mousemove', onMouseMove);
  overlay.addEventListener('mouseup', onMouseUp);
  overlay.addEventListener('mouseleave', onMouseUp);

  // --- Initialize ---
  fillStickersGrid('default');
  updateBackground();
  updateLayersPanel();

  // --- Keyboard shortcuts ---
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (activeElementId) {
        elements = elements.filter(el => el.id !== activeElementId);
        activeElementId = null;
        updateLayersPanel();
        redrawCanvas();
      }
    }
  });

  // --- Tooltip example ---
  canvas.addEventListener('mousemove', (evt) => {
    const pos = getMousePos(evt);
    tooltip.style.opacity = 0;
    for(let i=elements.length-1; i>=0; i--) {
      if (isPointInElement(pos.x, pos.y, elements[i])) {
        tooltip.textContent = `${elements[i].type.charAt(0).toUpperCase() + elements[i].type.slice(1)} ‚Äî Click & drag to move`;
        tooltip.style.left = evt.clientX + 15 + 'px';
        tooltip.style.top = evt.clientY + 15 + 'px';
        tooltip.style.opacity = 1;
        break;
      }
    }
  });
  canvas.addEventListener('mouseleave', () => {
    tooltip.style.opacity = 0;
  });

})();
</script>
</body>
</html>
